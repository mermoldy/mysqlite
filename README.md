# marble

A playground for learning database stuff.

The goal of this project is to build a toy SQLite clone by following the tutorial <https://cstack.github.io/db_tutorial> (C -> Rust) with [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)
and Client-Server architecture.

## Design

The internal architecture follows SQLiteâ€™s design:

<p align="center">
  <img src="https://cstack.github.io/db_tutorial/assets/images/arch2.gif"/>
</p>

## Storage

The marble storage backend is organized similarly to [InnoDB](https://dev.mysql.com/doc/refman/8.4/en/innodb-storage-engine.html). Each table has its own tablespace file (`.tbd`). The file contains a tablespace header and a set of fixed-size pages. Each page has its own header and a data section that stores actual rows. All pages are linked via previous/next relations, so the tablespace file represents a linked list of data pages.

## ðŸ“Œ SQLite Clone - Progress Tracker

First part is to imlement basic stuff using <https://cstack.github.io/db_tutorial>.

- [x] **Part 1** - Introduction and Setting up the REPL
- [x] **Part 2** - Worldâ€™s Simplest SQL Compiler and Virtual Machine
- [x] **Part 3** - An In-Memory, Append-Only, Single-Table Database
- [x] **Part 4** - Our First Tests (and Bugs)
- [x] **Part 5** - Persistence to Disk
- [x] **Part 6** - The Cursor Abstraction
- [x] **Part 7** - Introduction to the B-Tree
- [x] **Part 8** - B-Tree Leaf Node Format
- [x] **Part 9** - Binary Search and Duplicate Keys
- [x] **Part 10** - Splitting a Leaf Node
- [x] **Part 11** - Recursively Searching the B-Tree
- [x] **Part 12** - Scanning a Multi-Level B-Tree
- [x] **Part 13** - Updating Parent Node After a Split
- [ ] **Part 14** - Splitting Internal Nodes
- [ ] **Part 15** - Where to go next

### How SQLite works

A query goes through a chain of components in order to retrieve or modify data. The front-end consists of the:

- tokenizer
- parser
- code generator

The input to the front-end is a SQL query. the output is sqlite virtual machine bytecode (essentially a compiled program that can operate on the database).

The back-end consists of the:

- virtual machine
- B-tree
- pager
- os interface

The virtual machine takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. **The VM is essentially a big switch statement on the type of bytecode instruction.**

**Each B-tree consists of many nodes. Each node is one page in length.** The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager.

The pager receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk.

The os interface is the layer that differs depending on which operating system sqlite was compiled for.

### SQL

#### Statement structure

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/a/aa/SQL_ANATOMY_wiki.svg"/>
</p>

#### Order of execution

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230426205000/order-of-execution-of-SQL-query.png"/>
</p>
